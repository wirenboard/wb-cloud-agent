#!/usr/bin/env python3
import json
import logging
import subprocess
import sys
import time
from collections import namedtuple
from contextlib import ExitStack
from json import JSONDecodeError

from paho.mqtt.client import Client as MQTTClient

HTTP_200_OK = 204
HTTP_204_NO_CONTENT = 204
DEFAULT_CONF_FILE = "/mnt/data/etc/wb-cloud-agent.conf"


AppSettingsTuple = namedtuple(
    "AppSettingsTuple",
    [
        "LOG_LEVEL",
        "CLIENT_CERT_ENGINE_KEY",
        "CLIENT_CERT_FILE",
        "CLOUD_URL",
        "REQUEST_PERIOD_SECONDS",
        "FRP_SERVICE",
        "FRP_CONFIG",
        "TELEGRAF_SERVICE",
        "TELEGRAF_CONFIG",
        "ACTIVATION_LINK_CONFIG",
        "MQTT_PREFIX",
    ],
)


def AppSettingsBuilder(
    LOG_LEVEL="INFO",
    CLIENT_CERT_ENGINE_KEY="ATECCx08:00:02:C0:00",
    CLIENT_CERT_FILE="/var/lib/wb-cloud-agent/device_bundle.crt.pem",
    CLOUD_URL="https://agent.wirenboard.cloud/api-agent/v1/",
    REQUEST_PERIOD_SECONDS=3,
    FRP_SERVICE="wb-cloud-agent-frpc.service",
    FRP_CONFIG="/var/lib/wb-cloud-agent/frpc.conf",
    TELEGRAF_SERVICE="wb-cloud-agent-telegraf.service",
    TELEGRAF_CONFIG="/var/lib/wb-cloud-agent/telegraf.conf",
    ACTIVATION_LINK_CONFIG="/var/lib/wb-cloud-agent/activation_link.conf",
    MQTT_PREFIX="/devices/system__wb-cloud-agent",
):
    return AppSettingsTuple(
        LOG_LEVEL,
        CLIENT_CERT_ENGINE_KEY,
        CLIENT_CERT_FILE,
        CLOUD_URL,
        REQUEST_PERIOD_SECONDS,
        FRP_SERVICE,
        FRP_CONFIG,
        TELEGRAF_SERVICE,
        TELEGRAF_CONFIG,
        ACTIVATION_LINK_CONFIG,
        MQTT_PREFIX,
    )


def config_from_json_file(conf_file=None):
    if not conf_file:
        return AppSettingsBuilder()

    try:
        with open(conf_file, "r") as file:
            conf = file.read()
    except (FileNotFoundError, OSError):
        raise ValueError("Cannot read config file at: " + conf_file)

    try:
        conf = json.loads(conf)
    except JSONDecodeError:
        raise ValueError("Invalid config file format (must be valid json) at: " + conf_file)

    return AppSettingsBuilder(**conf)


settings = config_from_json_file(DEFAULT_CONF_FILE)


def setup_log():
    numeric_level = getattr(logging, settings.LOG_LEVEL.upper(), None)
    if not isinstance(numeric_level, int):
        raise ValueError("Invalid log level: %s" % settings.LOG_LEVEL)

    logging.basicConfig(level=numeric_level, format="%(message)s")


def do_curl(method="get", endpoint=""):
    CURL_BIN = "/usr/lib/wb-cloud-agent/curl-ssl1.1/curl.sh"

    data_delimiter = "|||"
    output_format = data_delimiter + '{"code":"%{response_code}"}'

    if method == "get":
        command = [CURL_BIN]
    elif method == "post":
        command = [CURL_BIN, "-X", "POST"]
    else:
        raise ValueError("Invalid method: " + method)

    url = settings.CLOUD_URL + endpoint

    command += [
        "--connect-timeout",
        "45",
        "--retry",
        "8",
        "--retry-max-time",
        "300",
        "--cert",
        settings.CLIENT_CERT_FILE,
        "--key",
        settings.CLIENT_CERT_ENGINE_KEY,
        "--engine",
        "ateccx08",
        "--key-type",
        "ENG",
        "-w",
        output_format,
        url,
    ]

    result = subprocess.run(command, timeout=360, check=True, stdout=subprocess.PIPE)

    decoded_result = result.stdout.decode("utf-8")
    split_result = decoded_result.split(data_delimiter)
    if len(split_result) != 2:
        raise ValueError("Invalid data in response: " + str(split_result))

    try:
        data = json.loads(split_result[0])
    except JSONDecodeError:
        data = {}

    try:
        status = int(json.loads(split_result[1])["code"])
    except (KeyError, TypeError, ValueError, JSONDecodeError):
        raise ValueError("Invalid data in response: " + str(split_result))

    return data, status


def update_activation_link(payload, mqtt):
    with open(settings.ACTIVATION_LINK_CONFIG, "w") as file:
        file.write(payload["activationLink"])

    publish_ctrl(mqtt, "activation_link", payload["activationLink"])


def update_tunnel_config(payload, mqtt):
    with open(settings.FRP_CONFIG, "w") as file:
        file.write(payload["config"])

    subprocess.run(["systemctl", "enable", settings.FRP_SERVICE], check=True)
    subprocess.run(["systemctl", "restart", settings.FRP_SERVICE], check=True)
    publish_ctrl(mqtt, "activation_link", "unknown")


def update_metrics_config(payload, mqtt):
    with open(settings.TELEGRAF_CONFIG, "w") as file:
        file.write(payload["config"])

    subprocess.run(["systemctl", "enable", settings.TELEGRAF_SERVICE], check=True)
    subprocess.run(["systemctl", "restart", settings.TELEGRAF_SERVICE], check=True)
    publish_ctrl(mqtt, "activation_link", "unknown")


HANDLERS = {
    "update_activation_link": update_activation_link,
    "update_tunnel_config": update_tunnel_config,
    "update_metrics_config": update_metrics_config,
}


def publish_vdev(mqtt):
    mqtt.publish(settings.MQTT_PREFIX + "/meta/name", "cloud status", retain=True, qos=2)
    mqtt.publish(settings.MQTT_PREFIX + "/meta/driver", "wb-cloud-agent", retain=True, qos=2)
    mqtt.publish(
        settings.MQTT_PREFIX + "/controls/status/meta",
        '{"type": "text", "readonly": true, "name": "status", "order": 1, "title": {"en": "Status"}}',
        retain=True,
        qos=2,
    )
    mqtt.publish(
        settings.MQTT_PREFIX + "/controls/activation_link/meta",
        '{"type": "text", "readonly": true, "name": "activation_link", "order": 2, "title": {"en": "Link"}}',
        retain=True,
        qos=2,
    )
    mqtt.publish(settings.MQTT_PREFIX + "/controls/status", "disconnected", retain=True, qos=2)
    mqtt.publish(settings.MQTT_PREFIX + "/controls/activation_link", "unknown", retain=True, qos=2)


def remove_vdev(mqtt):
    mqtt.publish(settings.MQTT_PREFIX + "/meta/name", "", retain=True, qos=2)
    mqtt.publish(settings.MQTT_PREFIX + "/meta/driver", "", retain=True, qos=2)
    mqtt.publish(settings.MQTT_PREFIX + "/controls/status/meta", "", retain=True, qos=2)
    mqtt.publish(settings.MQTT_PREFIX + "/controls/activation_link/meta", "", retain=True, qos=2)
    mqtt.publish(settings.MQTT_PREFIX + "/controls/status", "", retain=True, qos=2)
    mqtt.publish(settings.MQTT_PREFIX + "/controls/activation_link", "", retain=True, qos=2)


def publish_ctrl(mqtt, ctrl, value):
    mqtt.publish(settings.MQTT_PREFIX + "/controls/" + ctrl, value, retain=True, qos=2)


def make_request(mqtt):
    event_data, event_status = do_curl(method="get", endpoint="events/")
    logging.debug("Checked for new events. Status " + str(event_status) + ". Data: " + str(event_data))

    if event_status == HTTP_204_NO_CONTENT:
        return

    code = event_data.get("code", "")
    handler = HANDLERS.get(code)
    if not handler:
        raise ValueError("Unknown event code: " + str(code))

    event_id = event_data.get("id")
    if not handler:
        raise ValueError("Unknown event id: " + str(event_id))

    payload = event_data.get("payload")
    if not payload:
        raise ValueError("Empty payload")

    handler(payload, mqtt)
    logging.info("Event '" + code + "' handled successfully, event id " + str(event_id))

    _, confirmation_status = do_curl(method="post", endpoint="events/" + event_id + "/confirm/")

    if confirmation_status != HTTP_204_NO_CONTENT:
        raise ValueError("Not a 20X status on event confirmation: " + str(confirmation_status))


def main():
    setup_log()

    mqtt = MQTTClient("wb-cloud-agent")
    mqtt.connect("localhost", 1883)
    mqtt.loop_start()
    publish_vdev(mqtt)

    with ExitStack() as stack:
        stack.callback(remove_vdev, mqtt)

        while True:
            start = time.perf_counter()

            try:
                make_request(mqtt)
            except Exception as ex:
                logging.exception("Error making request to cloud!")
                publish_ctrl(mqtt, "status", "error:" + str(ex))
            else:
                publish_ctrl(mqtt, "status", "ok")

            request_time = time.perf_counter() - start

            logging.debug("Done in: " + str(int(request_time * 1000)) + " ms.")

            time.sleep(settings.REQUEST_PERIOD_SECONDS)


if __name__ == "__main__":
    sys.exit(main())

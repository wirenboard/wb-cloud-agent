#!/usr/bin/env python3
import json
import os
import subprocess
import sys
import time
from contextlib import ExitStack
from datetime import datetime
from json import JSONDecodeError

from wb_common.mqtt_client import MQTTClient

HTTP_200_OK = 204
HTTP_204_NO_CONTENT = 204

CONF_FILE = "/mnt/data/etc/wb-cloud-agent.conf"

CLIENT_CERT_FILE = os.getenv("WIRENBOARD_CLIENT_CERT_FILE", "/var/lib/wb-cloud-agent/device_bundle.crt.pem")
CLIENT_CERT_ENGINE_KEY = os.getenv("WIRENBOARD_CLIENT_CERT_ENGINE_KEY", "")

CLOUD_URL = os.getenv("WIRENBOARD_CLOUD_URL", "https://agent.wirenboard.cloud/api-agent/v1/")
FRP_CONFIG = os.getenv("WIRENBOARD_FRP_CONFIG", "/var/lib/wb-cloud-agent/frpc.conf")
TELEGRAF_CONFIG = os.getenv("WIRENBOARD_TELEGRAF_CONFIG", "/var/lib/wb-cloud-agent/telegraf.conf")
ACTIVATION_LINK_CONFIG = os.getenv(
    "WIRENBOARD_ACTIVATION_LINK_CONFIG", "/var/lib/wb-cloud-agent/activation_link.conf"
)

REQUEST_PERIOD_SECONDS = int(os.getenv("WIRENBOARD_REQUEST_PERIOD_SECONDS", "3"))

MQTT_PREFIX = "/devices/system__wb-cloud-agent"


def read_conf():
    with open(CONF_FILE, "r") as file:
        conf = file.read()

    try:
        conf = json.loads(conf)
    except JSONDecodeError:
        raise ValueError("Invalid config file at " + TELEGRAF_CONFIG)

    global CLIENT_CERT_ENGINE_KEY
    CLIENT_CERT_ENGINE_KEY = conf.get("CERT_ENGINE_KEY", "")


read_conf()


def do_curl(method="get", endpoint=""):
    data_delimiter = "|||"
    output_format = data_delimiter + '{"code":"%{response_code}"}'

    if method == "get":
        command = ["curl"]
    elif method == "post":
        command = ["curl", "-X", "POST"]
    else:
        raise ValueError("Invalid method: " + method)

    url = CLOUD_URL + endpoint

    command += [
        "--connect-timeout",
        "45",
        "--cert",
        CLIENT_CERT_FILE,
        "--key",
        CLIENT_CERT_ENGINE_KEY,
        "--engine",
        "ateccx08",
        "--key-type",
        "ENG",
        "-w",
        output_format,
        url,
    ]

    result = subprocess.run(command, timeout=60, check=True, capture_output=True)

    decoded_result = result.stdout.decode("utf-8")
    split_result = decoded_result.split(data_delimiter)
    if len(split_result) != 2:
        raise ValueError("Invalid data in response: " + str(split_result))

    try:
        data = json.loads(split_result[0])
    except JSONDecodeError:
        data = {}

    try:
        status = int(json.loads(split_result[1])["code"])
    except (KeyError, TypeError, ValueError, JSONDecodeError):
        raise ValueError("Invalid data in response: " + str(split_result))

    return data, status


def update_activation_link(payload, mqtt):
    with open(ACTIVATION_LINK_CONFIG, "w") as file:
        file.write(payload["activationLink"])

    publish_ctrl(mqtt, "activation_link", payload["activationLink"])


def update_tunnel_config(payload, mqtt):
    with open(FRP_CONFIG, "w") as file:
        file.write(payload["config"])

    subprocess.run(["systemctl", "enable", "wb-cloud-agent-frpc.service"], check=True)
    subprocess.run(["systemctl", "restart", "wb-cloud-agent-frpc.service"], check=True)
    publish_ctrl(mqtt, "activation_link", "unknown")


def update_metrics_config(payload, mqtt):
    with open(TELEGRAF_CONFIG, "w") as file:
        file.write(payload["config"])

    subprocess.run(["systemctl", "enable", "wb-cloud-agent-telegraf.service"], check=True)
    subprocess.run(["systemctl", "restart", "wb-cloud-agent-telegraf.service"], check=True)
    publish_ctrl(mqtt, "activation_link", "unknown")


HANDLERS = {
    "update_activation_link": update_activation_link,
    "update_tunnel_config": update_tunnel_config,
    "update_metrics_config": update_metrics_config,
}


def publish_vdev(mqtt):
    mqtt.publish(MQTT_PREFIX + "/meta/name", "cloud status", retain=True, qos=2)
    mqtt.publish(MQTT_PREFIX + "/meta/driver", "wb-cloud-agent", retain=True, qos=2)
    mqtt.publish(
        MQTT_PREFIX + "/controls/status/meta",
        '{"type": "text", "readonly": true, "name": "status", "order": 1, "title": {"en": "Status"}}',
        retain=True,
        qos=2,
    )
    mqtt.publish(
        MQTT_PREFIX + "/controls/activation_link/meta",
        '{"type": "text", "readonly": true, "name": "activation_link", "order": 2, "title": {"en": "Link"}}',
        retain=True,
        qos=2,
    )
    mqtt.publish(MQTT_PREFIX + "/controls/status", "disconnected", retain=True, qos=2)
    mqtt.publish(MQTT_PREFIX + "/controls/activation_link", "unknown", retain=True, qos=2)


def remove_vdev(mqtt):
    mqtt.publish(MQTT_PREFIX + "/meta/name", "", retain=True, qos=2)
    mqtt.publish(MQTT_PREFIX + "/meta/driver", "", retain=True, qos=2)
    mqtt.publish(MQTT_PREFIX + "/controls/status/meta", "", retain=True, qos=2)
    mqtt.publish(MQTT_PREFIX + "/controls/activation_link/meta", "", retain=True, qos=2)
    mqtt.publish(MQTT_PREFIX + "/controls/status", "", retain=True, qos=2)
    mqtt.publish(MQTT_PREFIX + "/controls/activation_link", "", retain=True, qos=2)


def publish_ctrl(mqtt, ctrl, value):
    mqtt.publish(MQTT_PREFIX + f"/controls/{ctrl}", value, retain=True, qos=2)


def make_request(mqtt):
    event_data, event_status = do_curl(method="get", endpoint="events/")
    print(datetime.now(), event_status, event_data)

    if event_status == HTTP_204_NO_CONTENT:
        return

    code = event_data.get("code", "")
    handler = HANDLERS.get(code)
    if not handler:
        raise ValueError("Unknown event code: " + str(code))

    event_id = event_data.get("id")
    if not handler:
        raise ValueError("Unknown event id: " + str(event_id))

    payload = event_data.get("payload")
    if not payload:
        raise ValueError("Empty payload")

    handler(payload, mqtt)
    print(datetime.now(), "Event handled successfully:", event_id)

    _, confirmation_status = do_curl(method="post", endpoint="events/" + event_id + "/confirm/")

    if confirmation_status != HTTP_204_NO_CONTENT:
        raise ValueError("Not a 20X status on event confirmation: " + confirmation_status)


def main():
    mqtt = MQTTClient("wb-cloud-agent")
    mqtt.start()
    publish_vdev(mqtt)

    with ExitStack() as stack:
        stack.callback(remove_vdev, mqtt)

        while True:
            start = time.perf_counter()

            try:
                make_request(mqtt)
            except Exception as ex:
                print(datetime.now(), "Error:", ex)
                publish_ctrl(mqtt, "status", "error:" + str(ex))
            else:
                publish_ctrl(mqtt, "status", "ok")

            request_time = time.perf_counter() - start

            print(datetime.now(), "Done in:", int(request_time * 1000), "ms", flush=True)

            time.sleep(REQUEST_PERIOD_SECONDS)


if __name__ == "__main__":
    sys.exit(main())
